using System.Threading.Tasks;

namespace SuperQueue;

/// <summary>
/// Интерфейс очереди, которую надо реализовать.
/// </summary>
public interface ISuperQueue
{
    /// <summary>
    /// Поставить задачу в очередь.
    /// </summary>
    /// <param name="job">Добавляемая задача.</param>
    void Enqueue(IJob job);
    /// <summary>
    /// Извлечь задачу из очереди.
    /// </summary>
    /// <returns>Следующая задача</returns>
    /// <remarks>Задачи из очереди должны извлекаться в порядке добавления в очередь, но с двумя особенностями:
    /// <list type="bullet">
    /// <item><description>задачи с большим приоритетом <see cref="IJob.Priority"/> должны быть извлечены раньше задач с меньшим приоритетом</description></item>
    /// <item><description>одновременно из очереди не может быть извлечено больше одной задачи с одинаковым <see cref="IJob.Owner"/>.
    /// Следование этому правилу должно иметь приоритет над предыдущим правилом, то есть наличие приоритетной задачи с одинаковым владельцем не
    /// предотвращает извлечение задач других владельцев с меньшим приоритетом.</description></item>
    /// </list>
    /// <para>Каждый объект-задача гарантировано вызывает событие <see cref="IJob.Completed"/> после успешного или не успешного выполнения. При успешном выполнении
    /// аргумент события <c>null</c> и задача больше не влияет на извлечение задач с тем же владельцем. При неуспешном выполнении аргумент события не равен
    /// <c>null</c> и задача должна быть поставлена в конец очереди и до последующего извлечения не влияет на извлечение задач с тем же владельцем.
    /// </para>
    /// <para>
    /// Если очередь пуста или остались только неизвлекаемые из-за второго правила задачи, возвращаемое значение должно быть <c>null</c>.
    /// </para>
    /// </remarks>
    Task<IJob> Dequeue();
    /// <summary>
    /// Длина очереди.
    /// </summary>
    int Count { get; }
}
